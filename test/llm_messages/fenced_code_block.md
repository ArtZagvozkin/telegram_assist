## Введение в асинхронное программирование на Python

Асинхронное программирование стало неотъемлемой частью современной разработки, особенно в задачах, связанных с вводом-выводом (I/O-bound operations), таких как сетевые запросы, работа с базами данных или файловые операции. В Python для этого существует мощный инструмент — модуль `asyncio`.

Основная идея асинхронности заключается в том, что вместо блокировки выполнения программы в ожидании завершения долгой операции, мы можем переключиться на выполнение другой задачи. Когда операция ввода-вывода завершится, управление вернется к ожидающей задаче.

### Основные концепции

Ключевыми элементами в экосистеме `asyncio` являются:

1. **Корутины (Coroutines):** Функции, определенные с помощью `async def`. Они могут быть приостановлены и возобновлены.
2. **Событийный цикл (Event Loop):** Механизм, который управляет выполнением корутин и обрабатывает события.
3. **Операторы `await`:** Используется для вызова других корутин и указания точке, где выполнение может быть приостановлено.

### Пример использования `asyncio`

Ниже представлен простой пример, демонстрирующий запуск двух асинхронных задач, которые имитируют задержку.

```python
import asyncio
import time

async def task_runner(task_name, delay):
    print(f"Task {task_name}: Starting. Will take {delay} seconds.")
    # Используем asyncio.sleep вместо time.sleep, чтобы не блокировать событийный цикл
    await asyncio.sleep(delay)
    print(f"Task {task_name}: Finished.")
    return f"Result from {task_name}"

async def main():
    start_time = time.time()

    # Запускаем обе задачи конкурентно
    results = await asyncio.gather(
        task_runner("A", 3),
        task_runner("B", 1)
    )

    end_time = time.time()
    print("-" * 20)
    print(f"Total execution time: {end_time - start_time:.2f} seconds")
    print(f"Results: {results}")

if __name__ == "__main__":
    # Запуск основного асинхронного цикла
    asyncio.run(main())
```

Если бы мы выполняли эти задачи последовательно, общее время составило бы $3 + 1 = 4$ секунды. Благодаря конкурентному выполнению (`asyncio.gather`), общее время выполнения будет равно времени самой долгой задачи, то есть около 3 секунд.

Изучение `asyncio` открывает двери для создания высокопроизводительных сетевых приложений на Python, которые могут обрабатывать тысячи одновременных подключений без необходимости использования многопоточности.